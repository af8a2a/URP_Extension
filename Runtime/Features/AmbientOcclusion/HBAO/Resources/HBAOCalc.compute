#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GlobalSamplers.hlsl"

#pragma kernel KMain

Texture2DArray<float> DepthInput;
Texture2D<float4> NormalInput;
RWTexture2DArray<float2> HBAO;

#define AO_RANDOMTEX_SIZE 4
#define DIRECTIONS  8
#define STEPS       6


float Radius; // radius
float R2; // 1/radius
float NegInvR2; // radius * radius
float NDotVBias;
float MaxRadiusPixels;
float2 InvFullResolution;
float2 InvQuarterResolution;

float AOMultiplier;
float PowExponent;

float MaxDistance;
float DistanceFalloff;

float4 jitters[AO_RANDOMTEX_SIZE * AO_RANDOMTEX_SIZE]; // angle, jitter,unused unused

half4 _SSAO_UVToView;


inline float3 GetNormalVS(int2 coord)
{
    float3 norm = NormalInput[coord];
    float3 view_Normal = normalize(mul((float3x3)unity_WorldToCamera, norm));
    return float3(view_Normal.xy, view_Normal.z);
}


inline half3 UVToView(half2 uv, half linearDepth)
{
    return half3((uv * _SSAO_UVToView.xy + _SSAO_UVToView.zw) * linearDepth, linearDepth);
}


float3 FetchQuarterResViewPos(float2 UV, int slice)
{
    float ViewDepth = DepthInput.SampleLevel(sampler_LinearClamp, float3(UV, slice), 0).x;
    return UVToView(UV, ViewDepth);
}

//----------------------------------------------------------------------------------
float Falloff(float DistanceSquare)
{
    // 1 scalar mad instruction
    return DistanceSquare * NegInvR2 + 1.0;
}

//----------------------------------------------------------------------------------
// P = view-space position at the kernel center
// N = view-space normal at the kernel center
// S = view-space position of the current sample
//----------------------------------------------------------------------------------
float ComputeAO(float3 P, float3 N, float3 S)
{
    float3 V = S - P;
    float VdotV = dot(V, V);
    float NdotV = dot(N, V) * 1.0 / sqrt(VdotV);

    // Use saturate(x) instead of max(x,0.f) because that is faster on Kepler
    return clamp(NdotV - NDotVBias, 0, 1) * clamp(Falloff(VdotV), 0, 1);
}


inline float3 FetchViewNormals(float2 uv)
{
    float3 N = NormalInput.SampleLevel(sampler_LinearClamp, uv, 0);
    N = normalize(TransformWorldToViewDir(N)); // normals are worldspace, convert to viewspace
    N = float3(N.x, -N.yz);
    return N;
}


float CalcAO(float2 uv, int slice)
{
    float3 P = FetchQuarterResViewPos(uv, slice);

    clip(MaxDistance - P.z < 0);

    float stepSize = min((Radius / P.z), MaxRadiusPixels) / (STEPS + 1.0);

    float3 N = FetchViewNormals(uv);
    //float2 rand = FetchNoise(positionSS);
    //float2 rand = FetchNoise(input.positionCS.xy);
    float2 rand = jitters[slice].xy;

    const float alpha = 2.0 * PI / DIRECTIONS;
    float ao = 0;

    UNITY_UNROLL
    for (int d = 0; d < DIRECTIONS; ++d)
    {
        float angle = alpha * (float(d) + rand.x);

        // Compute normalized 2D direction
        float cosA, sinA;
        sincos(angle, sinA, cosA);
        float2 direction = float2(cosA, sinA);

        // Jitter starting sample within the first step
        float rayPixels = (frac(rand.y) * stepSize + 1.0);

        UNITY_UNROLL
        for (int s = 0; s < STEPS; ++s)
        {
            float2 snappedUV = round(rayPixels * direction) * InvQuarterResolution.xy + uv;
            float3 S = FetchQuarterResViewPos(snappedUV, slice);

            rayPixels += stepSize;

            float contrib = ComputeAO(P, N, S);
            ao += contrib;
        }
    }


    float aoOutput = ao;

    // apply bias multiplier
    aoOutput *= (AOMultiplier / (STEPS * DIRECTIONS));

    float fallOffStart = MaxDistance - DistanceFalloff;
    float distFactor = saturate((P.z - fallOffStart) / (MaxDistance - fallOffStart));

    aoOutput = lerp(saturate(1 - aoOutput), 1, distFactor);
    return aoOutput;
}


[numthreads(8, 8, 1)]
void KMain(uint3 tid : SV_DispatchThreadID)
{
    float2 FullresUV = (floor(tid.xy) + 0.5) * (InvQuarterResolution);

    int slice = tid.z;
    float3 PositionVS = FetchQuarterResViewPos(FullresUV, slice);
    float4 NormalWS = NormalInput.SampleLevel(sampler_LinearClamp, FullresUV, 0);
    float3 NormalVS = GetNormalVS(NormalWS);



    HBAO[tid.xyz] = float4(pow(CalcAO(FullresUV, slice), PowExponent), PositionVS.z, 0, 0);
}
